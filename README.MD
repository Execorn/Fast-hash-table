# Fast hash table (using AVX2/ASM/SSE)

# О проекте

Перед прочтением данной статьи читателю настоятельно рекомендуется изучить:
### 1) [Структуру (Хеш-таблица)](https://en.wikipedia.org/wiki/Hash_table)
### 2) [SIMD-инструкции](https://ru.wikipedia.org/wiki/SIMD)
### 3) [CRC32-хеш](https://en.wikipedia.org/wiki/Cyclic_redundancy_check)

Целью данного проекта стояла реализация хеш-таблицы закрытого (!) типа и ее оптимизация с помощью Intrinsic-functions (SIMD-инструкции), ассемблерных вставок, а также ассемблерных функций. Важно заметить, что хеш-таблица должна быть универсальной - уметь работать с любыми типами ключей и значений. 

# Этапы выполнения работы и оптимизаций

##  Первая часть: написание хеш-таблицы

### Кратко о хеш-таблице:

За FILL-factor (size of hash table / capacity of hash table) было взято значение 0.72f (такое же, как в хеш-таблице в языке C#).
Опыт показал, что значения 0.7-0.75 оптимальны. Так, в языке Java используется значение 0.75f.

За GROWTH-factor было взято значение ~1.61 (1 + (sqrt(5) - 1) / 2), что, доказано математически, оптимально при обьеме данных, стремящемся к бесконечности.

Структуры хеш-таблицы и ее элемента (node_t, таблица построена на односвязных списках) задаются так:
![ht_t - хеш-таблица](img/ht_typedef.png)

![node_t - элемент односвязного списка](img/node_type.png)

### Важно отметить, что типы NODE_VALUE_TYPE и KEY_VALUE_TYPE задаются пользователем в специальном файле - [types_config.h](src/asm_optimise/types_config.h), что делает настройку хеш-таблицы очень удобной и простой.
Более того, все функции хеширования/сравнения ключей, а также возвращаемые default-параметры ключа и значения также кастомизируются  пользователем в файле [types_config](src/asm_optimise/types_config.h).



## Профилирование программы, первая оптимизация

После написания хеш-таблицы я начал замерять абсолютное и относительное время работы каждой функции с помощью инструмента [valgrind](https://valgrind.org/) под названием [callgrind](https://valgrind.org/docs/manual/cl-manual.html) 

Тут приведены результаты работы callgrind над программой, запущенной БЕЗ оптимизаций.
![Результаты работы callgrind без оптимизаций](link)

Очевидно, что самым важным для оптимизации и "узким" местом программы является функция HASH-6, то есть CRC32, являющаяся default-функцией для нахождения хешей в моей хеш-таблице. 

Я решил переписать свою хеш-функцию с использованием Intrinsic-функций (то есть, simd-инструкций). Изменив принцип хранения слов в своем тексте, выравнивая буффер для каждого слова по 32 (на самом деле - кладя все слова в один буффер по адресам, кратным 32), я узнал максимальную длину каждого слова (32 - абсолютный максимум, в выбранном мною тексте - "Война и мир", нет ни одного слова, длиннее 22 букв).
Это позволило мне использовать Intrinsic _mm_crc32_u64. Таким образом, время подсчета одного слова ограничивалось 4 итерациями цикла с нахождением crc32 (32 / 4). 

![Оптимизированная хеш-функция](img/optimized_hash.png)

Результат оптимизации превзошел все мои ожидания! Время работы хеш-функции уменьшилось в десятки раз!

![Результат работы callgrind с оптимизированной хеш-функцией](img/with_hash_callgrind.png):

## Вторая оптимизация

После первой оптимизацией стало очевидно, что, кроме функций find_node && ht_get узким местом моей программы являлась функция strcmp.
Изначально я использовал функцию strcmp из стандартной библиотеки языка C. Однако, благодаря первой выполненной оптимизации, теперь мне точно известная длина слова - 32 байта! Благодаря этому, я смог использовать Intrinsic _mm256_cmpeq_epi8, сравнивающий векторы.

![Оптимизированная функция avx_strcmp](img/avx_strcmp.png)

Это дало очень приятный результат: время работы strcmp также уменьшилось в десятки раз!


![Результат работы callgrind с оптимизированной strcmp](img/callgrind_strcmp_optimized.png)

![Результаты callgrind после оптимиизации "жадный ctc"](https://user-images.githubusercontent.com/26509840/162766453-e325da7f-419a-4c08-a219-f605c628c295.png)

Несложно понять, что, оказывается, узким местом моей программы являлась фунция main.

Что ж... Проанализировав код данной функции, я понял, что я трачу слишком много времени, сканируя из буффера по 1 байту, поэтому я решил сканировать сразу по 32 байта с помощью avx2 инструций!!! 

А после с помощью битовой магии я начал доставать по 1 слову из буфера, то есть вместо 1 символа за итерацию for'а я обрабатываю по целому слову.

## Третья часть

![Результаты callgrind после ускорения функции main](https://user-images.githubusercontent.com/26509840/162767165-36ca153c-f0c8-44a4-82d2-498608216783.png)

Судя по этим замечательным результатам, оптимизация фунции main прошла успешно, время выполнения программы уменьшилось в полтора раза, но из-за битовых операций нам потребовалось брать двоичный логарифм числа, который я брал с помощью for'ика, перебирая биты от 0 до 31.

Но моя реализация слишком много времени, поэтому я начал искать соответствующую инструцию процессора, и я её нашёл - это bsr!

## Четвёртая часть, заключительная

После всех этих оптимизаций я очень хотел поскорее узнать результат. И инструкция bsr сработала великолепно! Время выполнения программы относительно первой реализации уменьшилось в 2.5 раза!

![Результат после финальной оптимизации](https://user-images.githubusercontent.com/26509840/162768151-1c053a67-07e0-42e9-91ba-1aea39fac98c.png)

Как мы видим, узким местом программы снова стал хэш, но дальнейшая оптимизация не так и нужна...

# Тестирование хэш-функций

Также хочется показать вам результаты тестирования нескольких хэш-функций, по оси X вы можете наблюдать индекс хэша в хэш-таблице, а по оси Y - количество коллизий.

## Тестируемые функции

H1: Всегда возвращаем 1
H2: Возвращаем код первого ascii символа слова
H3: Возвразаем длину слова
H4: Возвращаем сумму ascii кодов слова
H5: H_0 = s[0]; H_i = rol(H_{i-1}) + s[i]
H6: crc32

## Результаты

![H1](https://user-images.githubusercontent.com/26509840/162768440-144869f7-aadc-4a4e-949b-acfa8fb1b209.png)
![H2](https://user-images.githubusercontent.com/26509840/162768447-98192dba-4395-4743-9345-136898861e26.png)
![H3](https://user-images.githubusercontent.com/26509840/162768451-f1271be9-a9da-4e1a-bba5-4c6ad664c6fe.png)
![H4](https://user-images.githubusercontent.com/26509840/162768452-158e9da8-a071-4402-b791-b1b8900b2d65.png)
![H5](https://user-images.githubusercontent.com/26509840/162768453-51ec6ef5-3046-42b1-8821-135560c6d652.png)
![H6](https://user-images.githubusercontent.com/26509840/162768456-a7de5b66-d2c0-453c-a657-371fd43b1036.png)
